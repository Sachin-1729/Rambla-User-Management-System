{"ast":null,"code":"import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from 'd3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from '../context/InteractionProvider';\nimport { useCartesianContext } from '../context/CartesianProvider';\nimport { getValueToPositionMapper } from '../hooks/useScale';\nimport { getSVGPoint } from '../internals/getSVGPoint';\nimport { useDrawingArea, useSvgRef } from '../hooks';\nimport { useHighlighted } from '../context';\nimport { useScatterSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = useScatterSeries() ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const lastFind = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisId,\n        yAxisId,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => {\n        const pointX = getXPosition(x);\n        const pointY = getYPosition(y);\n        if (!drawingArea.isPointInside({\n          x: pointX,\n          y: pointY\n        })) {\n          // If the point is not displayed we move them to a trash coordinate.\n          // This avoids managing index mapping before/after filtering.\n          // The trash point is far enough such that any point in the drawing area will be closer to the mouse than the trash coordinate.\n          return [-drawingArea.width, -drawingArea.height];\n        }\n        return [pointX, pointY];\n      });\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n    lastFind.current = undefined;\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null) {\n      return undefined;\n    }\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(svgPoint)) {\n        lastFind.current = undefined;\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      lastFind.current = closestPointIndex;\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseLeave = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('pointerleave', handleMouseLeave);\n    element.addEventListener('pointermove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('pointerleave', handleMouseLeave);\n      element.removeEventListener('pointermove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };","map":{"version":3,"names":["React","PropTypes","Delaunay","useEnhancedEffect","InteractionContext","useCartesianContext","getValueToPositionMapper","getSVGPoint","useDrawingArea","useSvgRef","useHighlighted","useScatterSeries","jsx","_jsx","ChartsVoronoiHandler","props","voronoiMaxRadius","onItemClick","svgRef","drawingArea","xAxis","yAxis","xAxisIds","yAxisIds","dispatch","useContext","series","seriesOrder","voronoiRef","useRef","delauneyRef","undefined","lastFind","setHighlighted","clearHighlighted","defaultXAxisId","defaultYAxisId","type","useVoronoiInteraction","current","points","forEach","seriesId","data","xAxisId","yAxisId","xAxisKey","yAxisKey","xScale","scale","yScale","getXPosition","getYPosition","seriesPoints","flatMap","x","y","pointX","pointY","isPointInside","width","height","startIndex","length","endIndex","concat","useEffect","element","getClosestPoint","event","svgPoint","closestPointIndex","find","closestSeries","Object","values","value","dataIndex","dist2","handleMouseLeave","handleMouseMove","closestPoint","handleMouseClick","addEventListener","removeEventListener","Fragment","process","env","NODE_ENV","propTypes","func","number"],"sources":["C:/Users/amris/OneDrive/Desktop/Rambla/frontend/node_modules/@mui/x-charts/esm/ChartsVoronoiHandler/ChartsVoronoiHandler.js"],"sourcesContent":["import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from 'd3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from '../context/InteractionProvider';\nimport { useCartesianContext } from '../context/CartesianProvider';\nimport { getValueToPositionMapper } from '../hooks/useScale';\nimport { getSVGPoint } from '../internals/getSVGPoint';\nimport { useDrawingArea, useSvgRef } from '../hooks';\nimport { useHighlighted } from '../context';\nimport { useScatterSeries } from '../hooks/useSeries';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = useScatterSeries() ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const lastFind = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisId,\n        yAxisId,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => {\n        const pointX = getXPosition(x);\n        const pointY = getYPosition(y);\n        if (!drawingArea.isPointInside({\n          x: pointX,\n          y: pointY\n        })) {\n          // If the point is not displayed we move them to a trash coordinate.\n          // This avoids managing index mapping before/after filtering.\n          // The trash point is far enough such that any point in the drawing area will be closer to the mouse than the trash coordinate.\n          return [-drawingArea.width, -drawingArea.height];\n        }\n        return [pointX, pointY];\n      });\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n    lastFind.current = undefined;\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null) {\n      return undefined;\n    }\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(svgPoint)) {\n        lastFind.current = undefined;\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      lastFind.current = closestPointIndex;\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseLeave = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('pointerleave', handleMouseLeave);\n    element.addEventListener('pointermove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('pointerleave', handleMouseLeave);\n      element.removeEventListener('pointermove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}